digraph {
    ranksep =.2;
    managedorexternal[label="Managed or External"]
    cliorserv[label="Client or Server"]
    managedclient[label="do_managed_client()"]
    managedserver[label="do_managed_server()"]
    clientpy[label="client.py"]
    servpy[label="server.py"]
    clientinit[label="Client pyptlib initiate.\nrecieve supported transports\nand stateLocation"]
    setclientconfig[label="set client config\nlistenermode=socks\nobfsproxmode=managed"]
    gettransportclasssetup[label="get transport class and run:\ntransport_class.setup(pt_config)"]
    launchlistener[label="launch_transport_listener()\n"]
    launch_transportpy[label="launch_transport.py"]
    gettransportclass[label="get transport class"]
    setaddrport[label="Set address and host.\nlocalhost for client mode"]
    checkrole[label="Check Role"]
    startsocks[label="OBFSOCKSv5Factory"]
    startorport[label="ExtORPortServerFactory"]
    startstaticserver[label="StaticDestinationServerFactory"]
    factoryresult[label="return factory result"]
    openreactor[label="reactor.listenTCP(port, factor result^, interface\nreturn addr and port"]
    waslaunchsuccess[label="was transport launch sucessful?"]
    reportend[label="Report end, accept traffic from tor,\nstart reactor event loop"]
    reporterror[label="Report error"]
    servinit[label="server pyptlib initiate, recieve orport,\nextorport, transports, and stateLocation"]
    setservconfig[label="set server config^"]
    isserver[label="Is Server?"]
    enumaddrs[label="are all transports launched\non all addrs?"]

    managedorexternal -> cliorserv[label="managed"];
    cliorserv->managedclient[label="client"];
    cliorserv->managedserver[label="server"];
    managedclient->clientpy;
    managedserver->servpy;
    clientpy->clientinit->setclientconfig
    setclientconfig->gettransportclasssetup[label="transports.py"]
    gettransportclasssetup->launchlistener[label="client.py"]
    launchlistener->launch_transportpy;
    launch_transportpy->gettransportclass[label="transports.py"];
    gettransportclass->setaddrport[label="launch_transport.py"]
    setaddrport->checkrole;
    checkrole->startsocks[label="socks/client\n{socks.py}"]
    checkrole->startorport[label="ext_server/server\n{extended_orport.py"]
    checkrole->startstaticserver[label="norole, static dst server\n{network.py}"]
    #after done with socks and orport server factory, the tcp listener is opened using reactor
    #return host addr and port
    startsocks->factoryresult
    startorport->factoryresult
    startstaticserver->factoryresult
    factoryresult->openreactor
    openreactor->waslaunchsuccess[label="back to client/server.py"]
    waslaunchsuccess->isserver[label="yes"]
    isserver->enumaddrs[label="yes"]
    isserver->reportend[label="no"]
    enumaddrs->reportend[label="yes"]
    enumaddrs->launch_transportpy[label="no"]
    waslaunchsuccess->reporterror[label="no"]
    servpy->servinit->setservconfig->gettransportclasssetup[label="transports.py"]

}
        